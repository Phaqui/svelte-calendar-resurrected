import './Popover.svelte.css.proxy.js';
/* src/Components/Popover.svelte generated by Svelte v3.41.0 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	binding_callbacks,
	check_outros,
	create_slot,
	detach,
	element,
	get_all_dirty_from_scope,
	get_slot_changes,
	globals,
	group_outros,
	init,
	insert,
	listen,
	safe_not_equal,
	space,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} from "../../_snowpack/pkg/svelte/internal.js";

const { window: window_1 } = globals;
import { onMount, onDestroy, createEventDispatcher, tick } from '../../_snowpack/pkg/svelte.js';
const get_contents_slot_changes = dirty => ({});
const get_contents_slot_context = ctx => ({});
const get_trigger_slot_changes = dirty => ({});
const get_trigger_slot_context = ctx => ({});

// (114:2) {#if !alwaysOpen}
function create_if_block(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const trigger_slot_template = /*#slots*/ ctx[15].trigger;
	const trigger_slot = create_slot(trigger_slot_template, ctx, /*$$scope*/ ctx[14], get_trigger_slot_context);

	return {
		c() {
			div = element("div");
			if (trigger_slot) trigger_slot.c();
			attr(div, "class", "trigger");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (trigger_slot) {
				trigger_slot.m(div, null);
			}

			/*div_binding*/ ctx[17](div);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*doOpen*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (trigger_slot) {
				if (trigger_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						trigger_slot,
						trigger_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(trigger_slot_template, /*$$scope*/ ctx[14], dirty, get_trigger_slot_changes),
						get_trigger_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(trigger_slot, local);
			current = true;
		},
		o(local) {
			transition_out(trigger_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (trigger_slot) trigger_slot.d(detaching);
			/*div_binding*/ ctx[17](null);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div3;
	let t;
	let div2;
	let div1;
	let div0;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[16]);
	let if_block = !/*alwaysOpen*/ ctx[2] && create_if_block(ctx);
	const contents_slot_template = /*#slots*/ ctx[15].contents;
	const contents_slot = create_slot(contents_slot_template, ctx, /*$$scope*/ ctx[14], get_contents_slot_context);

	return {
		c() {
			div3 = element("div");
			if (if_block) if_block.c();
			t = space();
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (contents_slot) contents_slot.c();
			attr(div0, "class", "contents-inner svelte-x1pkfs");
			attr(div1, "class", "contents svelte-x1pkfs");
			attr(div2, "class", "contents-wrapper svelte-x1pkfs");
			attr(div2, "style", /*contentsWrapperStyles*/ ctx[8]);
			toggle_class(div2, "always-open", /*alwaysOpen*/ ctx[2]);
			toggle_class(div2, "visible", /*alwaysOpen*/ ctx[2] || /*open*/ ctx[0]);
			toggle_class(div2, "shrink", /*shrink*/ ctx[1]);
			attr(div3, "class", "sc-popover svelte-x1pkfs");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			if (if_block) if_block.m(div3, null);
			append(div3, t);
			append(div3, div2);
			append(div2, div1);
			append(div1, div0);

			if (contents_slot) {
				contents_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[18](div1);
			/*div2_binding*/ ctx[19](div2);
			/*div3_binding*/ ctx[20](div3);
			current = true;

			if (!mounted) {
				dispose = listen(window_1, "resize", /*onwindowresize*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!/*alwaysOpen*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*alwaysOpen*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div3, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (contents_slot) {
				if (contents_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						contents_slot,
						contents_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(contents_slot_template, /*$$scope*/ ctx[14], dirty, get_contents_slot_changes),
						get_contents_slot_context
					);
				}
			}

			if (!current || dirty & /*contentsWrapperStyles*/ 256) {
				attr(div2, "style", /*contentsWrapperStyles*/ ctx[8]);
			}

			if (dirty & /*alwaysOpen*/ 4) {
				toggle_class(div2, "always-open", /*alwaysOpen*/ ctx[2]);
			}

			if (dirty & /*alwaysOpen, open*/ 5) {
				toggle_class(div2, "visible", /*alwaysOpen*/ ctx[2] || /*open*/ ctx[0]);
			}

			if (dirty & /*shrink*/ 2) {
				toggle_class(div2, "shrink", /*shrink*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(contents_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(contents_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			if (if_block) if_block.d();
			if (contents_slot) contents_slot.d(detaching);
			/*div1_binding*/ ctx[18](null);
			/*div2_binding*/ ctx[19](null);
			/*div3_binding*/ ctx[20](null);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let contentsWrapperStyles;
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();

	let once = (el, evt, cb) => {
		function handler() {
			cb.apply(this, arguments);
			el.removeEventListener(evt, handler);
		}

		el.addEventListener(evt, handler);
	};

	let popover;
	let w;
	let triggerContainer;
	let contentsAnimated;
	let contentsWrapper;
	let translateY = 0;
	let translateX = 0;
	let { open = false } = $$props;
	let { alwaysOpen = false } = $$props;
	let { shrink } = $$props;
	let { trigger } = $$props;

	const close = () => {
		if (alwaysOpen) return;
		$$invalidate(1, shrink = true);

		once(contentsAnimated, 'animationend', () => {
			$$invalidate(1, shrink = false);
			$$invalidate(0, open = false);
			dispatch('closed');
		});
	};

	function checkForFocusLoss(evt) {
		if (!open) return;
		let el = evt.target;

		// eslint-disable-next-line
		do {
			if (el === popover) return;
		} while (el = el.parentNode); // eslint-disable-next-line

		close();
	}

	onMount(() => {
		document.addEventListener('click', checkForFocusLoss);
		if (!trigger) return;
		triggerContainer.appendChild(trigger.parentNode.removeChild(trigger));

		// eslint-disable-next-line
		return () => {
			document.removeEventListener('click', checkForFocusLoss);
		};
	});

	onDestroy(() => {
		document.removeEventListener("click", checkForFocusLoss);
	});

	const getDistanceToEdges = async () => {
		if (!open) {
			$$invalidate(0, open = true);
		}

		await tick();
		let rect = contentsWrapper.getBoundingClientRect();

		return {
			top: rect.top + -1 * translateY,
			bottom: window.innerHeight - rect.bottom + translateY,
			left: rect.left + -1 * translateX,
			right: document.body.clientWidth - rect.right + translateX
		};
	};

	const getTranslate = async () => {
		let dist = await getDistanceToEdges();
		let x;
		let y;

		if (w < 480) {
			y = dist.bottom;
		} else if (dist.top < 0) {
			y = Math.abs(dist.top);
		} else if (dist.bottom < 0) {
			y = dist.bottom;
		} else {
			y = 0;
		}

		if (dist.left < 0) {
			x = Math.abs(dist.left);
		} else if (dist.right < 0) {
			x = dist.right;
		} else {
			x = 0;
		}

		return { x, y };
	};

	const doOpen = async () => {
		const { x, y } = await getTranslate();
		$$invalidate(13, translateX = x);
		$$invalidate(12, translateY = y);
		$$invalidate(0, open = true);
		dispatch('opened');
	};

	function onwindowresize() {
		$$invalidate(4, w = window_1.innerWidth)
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			triggerContainer = $$value;
			$$invalidate(5, triggerContainer);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contentsAnimated = $$value;
			$$invalidate(6, contentsAnimated);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contentsWrapper = $$value;
			$$invalidate(7, contentsWrapper);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			popover = $$value;
			$$invalidate(3, popover);
		});
	}

	$$self.$$set = $$props => {
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
		if ('alwaysOpen' in $$props) $$invalidate(2, alwaysOpen = $$props.alwaysOpen);
		if ('shrink' in $$props) $$invalidate(1, shrink = $$props.shrink);
		if ('trigger' in $$props) $$invalidate(10, trigger = $$props.trigger);
		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*alwaysOpen, translateX, translateY*/ 12292) {
			$: $$invalidate(8, contentsWrapperStyles = alwaysOpen
			? ""
			: `transform: translate(-50%,-50%) translate(${translateX}px, ${translateY}px)`);
		}
	};

	return [
		open,
		shrink,
		alwaysOpen,
		popover,
		w,
		triggerContainer,
		contentsAnimated,
		contentsWrapper,
		contentsWrapperStyles,
		doOpen,
		trigger,
		close,
		translateY,
		translateX,
		$$scope,
		slots,
		onwindowresize,
		div_binding,
		div1_binding,
		div2_binding,
		div3_binding
	];
}

class Popover extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			open: 0,
			alwaysOpen: 2,
			shrink: 1,
			trigger: 10,
			close: 11
		});
	}

	get close() {
		return this.$$.ctx[11];
	}
}

export default Popover;