import './Datepicker.svelte.css.proxy.js';
/* src/Components/Datepicker.svelte generated by Svelte v3.41.0 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	create_component,
	create_slot,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	get_all_dirty_from_scope,
	get_slot_changes,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	space,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} from "../../_snowpack/pkg/svelte/internal.js";

import Month from './Month.svelte.js';
import NavBar from './NavBar.svelte.js';
import Popover from './Popover.svelte.js';
import { getMonths } from './lib/helpers.js';
import { formatDate, internationalize } from '../../_snowpack/pkg/timeUtils.js';
import { keyCodes, keyCodesArray } from './lib/keyCodes.js';
import { onMount, createEventDispatcher } from '../../_snowpack/pkg/svelte.js';

const get_default_slot_changes = dirty => ({
	selected: dirty[0] & /*selected*/ 1,
	formattedSelected: dirty[0] & /*formattedSelected*/ 4
});

const get_default_slot_context = ctx => ({
	selected: /*selected*/ ctx[0],
	formattedSelected: /*formattedSelected*/ ctx[2]
});

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[69] = list[i];
	return child_ctx;
}

// (290:8) {#if !trigger}
function create_if_block(ctx) {
	let button;
	let t;

	return {
		c() {
			button = element("button");
			t = text(/*formattedSelected*/ ctx[2]);
			attr(button, "class", "calendar-button svelte-1m1jgwa");
			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*formattedSelected*/ 4) set_data(t, /*formattedSelected*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (289:43)          
function fallback_block(ctx) {
	let if_block_anchor;
	let if_block = !/*trigger*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (!/*trigger*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (288:4) 
function create_trigger_slot(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[45].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[53], get_default_slot_context);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	return {
		c() {
			div = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(div, "slot", "trigger");
			attr(div, "class", "svelte-1m1jgwa");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*selected, formattedSelected*/ 5 | dirty[1] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[53],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[53])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[53], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*formattedSelected, trigger*/ 6)) {
					default_slot_or_fallback.p(ctx, !current ? [-1, -1, -1] : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (312:10) {#each sortedDaysOfWeek as day}
function create_each_block(ctx) {
	let span;
	let t_value = /*day*/ ctx[69][1] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "svelte-1m1jgwa");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (297:4) 
function create_contents_slot(ctx) {
	let div2;
	let div1;
	let navbar;
	let t0;
	let div0;
	let t1;
	let month_1;
	let current;

	navbar = new NavBar({
			props: {
				month: /*month*/ ctx[7],
				year: /*year*/ ctx[8],
				canIncrementMonth: /*canIncrementMonth*/ ctx[16],
				canDecrementMonth: /*canDecrementMonth*/ ctx[15],
				start: /*start*/ ctx[3],
				end: /*end*/ ctx[4],
				monthsOfYear: /*monthsOfYear*/ ctx[6]
			}
		});

	navbar.$on("monthSelected", /*monthSelected_handler*/ ctx[46]);
	navbar.$on("yearSelected", /*yearSelected_handler*/ ctx[47]);
	navbar.$on("incrementMonth", /*incrementMonth_handler*/ ctx[48]);
	let each_value = /*sortedDaysOfWeek*/ ctx[19];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	month_1 = new Month({
			props: {
				visibleMonth: /*visibleMonth*/ ctx[9],
				selected: /*selected*/ ctx[0],
				highlighted: /*highlighted*/ ctx[11],
				shouldShakeDate: /*shouldShakeDate*/ ctx[12],
				id: /*visibleMonthId*/ ctx[18]
			}
		});

	month_1.$on("dateSelected", /*dateSelected_handler*/ ctx[49]);

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			create_component(navbar.$$.fragment);
			t0 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			create_component(month_1.$$.fragment);
			attr(div0, "class", "legend svelte-1m1jgwa");
			attr(div1, "class", "calendar svelte-1m1jgwa");
			attr(div2, "slot", "contents");
			attr(div2, "class", "svelte-1m1jgwa");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			mount_component(navbar, div1, null);
			append(div1, t0);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append(div1, t1);
			mount_component(month_1, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const navbar_changes = {};
			if (dirty[0] & /*month*/ 128) navbar_changes.month = /*month*/ ctx[7];
			if (dirty[0] & /*year*/ 256) navbar_changes.year = /*year*/ ctx[8];
			if (dirty[0] & /*canIncrementMonth*/ 65536) navbar_changes.canIncrementMonth = /*canIncrementMonth*/ ctx[16];
			if (dirty[0] & /*canDecrementMonth*/ 32768) navbar_changes.canDecrementMonth = /*canDecrementMonth*/ ctx[15];
			if (dirty[0] & /*start*/ 8) navbar_changes.start = /*start*/ ctx[3];
			if (dirty[0] & /*end*/ 16) navbar_changes.end = /*end*/ ctx[4];
			if (dirty[0] & /*monthsOfYear*/ 64) navbar_changes.monthsOfYear = /*monthsOfYear*/ ctx[6];
			navbar.$set(navbar_changes);

			if (dirty[0] & /*sortedDaysOfWeek*/ 524288) {
				each_value = /*sortedDaysOfWeek*/ ctx[19];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const month_1_changes = {};
			if (dirty[0] & /*visibleMonth*/ 512) month_1_changes.visibleMonth = /*visibleMonth*/ ctx[9];
			if (dirty[0] & /*selected*/ 1) month_1_changes.selected = /*selected*/ ctx[0];
			if (dirty[0] & /*highlighted*/ 2048) month_1_changes.highlighted = /*highlighted*/ ctx[11];
			if (dirty[0] & /*shouldShakeDate*/ 4096) month_1_changes.shouldShakeDate = /*shouldShakeDate*/ ctx[12];
			if (dirty[0] & /*visibleMonthId*/ 262144) month_1_changes.id = /*visibleMonthId*/ ctx[18];
			month_1.$set(month_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(month_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(month_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(navbar);
			destroy_each(each_blocks, detaching);
			destroy_component(month_1);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let popover_1;
	let updating_open;
	let updating_shrink;
	let current;

	function popover_1_open_binding(value) {
		/*popover_1_open_binding*/ ctx[51](value);
	}

	function popover_1_shrink_binding(value) {
		/*popover_1_shrink_binding*/ ctx[52](value);
	}

	let popover_1_props = {
		trigger: /*trigger*/ ctx[1],
		alwaysOpen: /*alwaysOpen*/ ctx[5],
		$$slots: {
			contents: [create_contents_slot],
			trigger: [create_trigger_slot]
		},
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[13] !== void 0) {
		popover_1_props.open = /*isOpen*/ ctx[13];
	}

	if (/*isClosing*/ ctx[14] !== void 0) {
		popover_1_props.shrink = /*isClosing*/ ctx[14];
	}

	popover_1 = new Popover({ props: popover_1_props });
	/*popover_1_binding*/ ctx[50](popover_1);
	binding_callbacks.push(() => bind(popover_1, 'open', popover_1_open_binding));
	binding_callbacks.push(() => bind(popover_1, 'shrink', popover_1_shrink_binding));
	popover_1.$on("opened", /*registerOpen*/ ctx[25]);
	popover_1.$on("closed", /*registerClose*/ ctx[24]);

	return {
		c() {
			div = element("div");
			create_component(popover_1.$$.fragment);
			attr(div, "class", "datepicker svelte-1m1jgwa");
			attr(div, "style", /*wrapperStyle*/ ctx[17]);
			toggle_class(div, "open", /*isOpen*/ ctx[13]);
			toggle_class(div, "closing", /*isClosing*/ ctx[14]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(popover_1, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const popover_1_changes = {};
			if (dirty[0] & /*trigger*/ 2) popover_1_changes.trigger = /*trigger*/ ctx[1];
			if (dirty[0] & /*alwaysOpen*/ 32) popover_1_changes.alwaysOpen = /*alwaysOpen*/ ctx[5];

			if (dirty[0] & /*visibleMonth, selected, highlighted, shouldShakeDate, visibleMonthId, month, year, canIncrementMonth, canDecrementMonth, start, end, monthsOfYear, formattedSelected, trigger*/ 367583 | dirty[1] & /*$$scope*/ 4194304) {
				popover_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty[0] & /*isOpen*/ 8192) {
				updating_open = true;
				popover_1_changes.open = /*isOpen*/ ctx[13];
				add_flush_callback(() => updating_open = false);
			}

			if (!updating_shrink && dirty[0] & /*isClosing*/ 16384) {
				updating_shrink = true;
				popover_1_changes.shrink = /*isClosing*/ ctx[14];
				add_flush_callback(() => updating_shrink = false);
			}

			popover_1.$set(popover_1_changes);

			if (!current || dirty[0] & /*wrapperStyle*/ 131072) {
				attr(div, "style", /*wrapperStyle*/ ctx[17]);
			}

			if (dirty[0] & /*isOpen*/ 8192) {
				toggle_class(div, "open", /*isOpen*/ ctx[13]);
			}

			if (dirty[0] & /*isClosing*/ 16384) {
				toggle_class(div, "closing", /*isClosing*/ ctx[14]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(popover_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(popover_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*popover_1_binding*/ ctx[50](null);
			destroy_component(popover_1);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let months;
	let visibleMonth;
	let visibleMonthId;
	let lastVisibleDate;
	let firstVisibleDate;
	let canIncrementMonth;
	let canDecrementMonth;
	let wrapperStyle;
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	const today = new Date();
	const oneYear = 1000 * 60 * 60 * 24 * 365;
	let popover;
	let { format = '#{m}/#{d}/#{Y}' } = $$props;
	let { start = new Date(Date.now() - oneYear) } = $$props;
	let { end = new Date(Date.now() + oneYear) } = $$props;
	let { selected = today } = $$props;
	let { dateChosen = false } = $$props;
	let { alwaysOpen = false } = $$props;
	let { trigger = null } = $$props;
	let { selectableCallback = null } = $$props;
	let { weekStart = 0 } = $$props;

	let { daysOfWeek = [
		['Sunday', 'Sun'],
		['Monday', 'Mon'],
		['Tuesday', 'Tue'],
		['Wednesday', 'Wed'],
		['Thursday', 'Thu'],
		['Friday', 'Fri'],
		['Saturday', 'Sat']
	] } = $$props;

	let { monthsOfYear = [
		['January', 'Jan'],
		['February', 'Feb'],
		['March', 'Mar'],
		['April', 'Apr'],
		['May', 'May'],
		['June', 'Jun'],
		['July', 'Jul'],
		['August', 'Aug'],
		['September', 'Sep'],
		['October', 'Oct'],
		['November', 'Nov'],
		['December', 'Dec']
	] } = $$props;

	selected = selected.getTime() < start.getTime() || selected.getTime() > end.getTime()
	? start
	: selected;

	let { style = '' } = $$props;
	let { buttonBackgroundColor = '#fff' } = $$props;
	let { buttonBorderColor = '#eee' } = $$props;
	let { buttonTextColor = '#333' } = $$props;
	let { highlightColor = '#f7901e' } = $$props;
	let { dayBackgroundColor = 'none' } = $$props;
	let { dayTextColor = '#4a4a4a' } = $$props;
	let { dayBorderColor = '#fff' } = $$props;
	let { dayHighlightedBackgroundColor = '#efefef' } = $$props;
	let { dayHighlightedTextColor = '#4a4a4a' } = $$props;
	let { backgroundColor = '#ffffff' } = $$props;
	let { textColor = '#3d4548' } = $$props;
	internationalize({ daysOfWeek, monthsOfYear });

	let sortedDaysOfWeek = weekStart === 0
	? daysOfWeek
	: (() => {
			let dow = daysOfWeek.slice();
			dow.push(dow.shift());
			return dow;
		})();

	let highlighted = today;
	let shouldShakeDate = false;
	let shakeHighlightTimeout;
	let month = today.getMonth();
	let year = today.getFullYear();
	let isOpen = false;
	let isClosing = false;
	today.setHours(0, 0, 0, 0);

	function assignmentHandler(formatted) {
		if (!trigger || alwaysOpen) return;
		$$invalidate(1, trigger.innerHTML = formatted, trigger);
	}

	let monthIndex = 0;
	let { formattedSelected } = $$props;

	onMount(() => {
		$$invalidate(7, month = selected.getMonth());
		$$invalidate(8, year = selected.getFullYear());
	});

	function changeMonth(selectedMonth) {
		$$invalidate(7, month = selectedMonth);
		$$invalidate(11, highlighted = new Date(year, month, 1));
	}

	function changeYear(selectedYear) {
		$$invalidate(8, year = selectedYear);
		$$invalidate(11, highlighted = new Date(year, month, 1));
	}

	function incrementMonth(direction, day = 1) {
		if (direction === 1 && !canIncrementMonth) return;
		if (direction === -1 && !canDecrementMonth) return;
		let current = new Date(year, month, 1);
		current.setMonth(current.getMonth() + direction);
		$$invalidate(7, month = current.getMonth());
		$$invalidate(8, year = current.getFullYear());
		$$invalidate(11, highlighted = new Date(year, month, day));
	}

	function getDefaultHighlighted() {
		return new Date(selected);
	}

	const getDay = (m, d, y) => {
		let theMonth = months.find(aMonth => aMonth.month === m && aMonth.year === y);
		if (!theMonth) return null;

		// eslint-disable-next-line
		for (let i = 0; i < theMonth.weeks.length; ++i) {
			// eslint-disable-next-line
			for (let j = 0; j < theMonth.weeks[i].days.length; ++j) {
				let aDay = theMonth.weeks[i].days[j];
				if (aDay.month === m && aDay.day === d && aDay.year === y) return aDay;
			}
		}

		return null;
	};

	function incrementDayHighlighted(amount) {
		let proposedDate = new Date(highlighted);
		proposedDate.setDate(highlighted.getDate() + amount);
		let correspondingDayObj = getDay(proposedDate.getMonth(), proposedDate.getDate(), proposedDate.getFullYear());
		if (!correspondingDayObj || !correspondingDayObj.isInRange) return;
		$$invalidate(11, highlighted = proposedDate);

		if (amount > 0 && highlighted > lastVisibleDate) {
			incrementMonth(1, highlighted.getDate());
		}

		if (amount < 0 && highlighted < firstVisibleDate) {
			incrementMonth(-1, highlighted.getDate());
		}
	}

	function checkIfVisibleDateIsSelectable(date) {
		const proposedDay = getDay(date.getMonth(), date.getDate(), date.getFullYear());
		return proposedDay && proposedDay.selectable;
	}

	function shakeDate(date) {
		clearTimeout(shakeHighlightTimeout);
		$$invalidate(12, shouldShakeDate = date);

		shakeHighlightTimeout = setTimeout(
			() => {
				$$invalidate(12, shouldShakeDate = false);
			},
			700
		);
	}

	function assignValueToTrigger(formatted) {
		assignmentHandler(formatted);
	}

	function registerSelection(chosen) {
		if (!checkIfVisibleDateIsSelectable(chosen)) return shakeDate(chosen);

		// eslint-disable-next-line
		close();

		$$invalidate(0, selected = chosen);
		$$invalidate(26, dateChosen = true);
		assignValueToTrigger(formattedSelected);
		return dispatch('dateSelected', { date: chosen });
	}

	function handleKeyPress(evt) {
		if (keyCodesArray.indexOf(evt.keyCode) === -1) return;
		evt.preventDefault();

		switch (evt.keyCode) {
			case keyCodes.left:
				incrementDayHighlighted(-1);
				break;
			case keyCodes.up:
				incrementDayHighlighted(-7);
				break;
			case keyCodes.right:
				incrementDayHighlighted(1);
				break;
			case keyCodes.down:
				incrementDayHighlighted(7);
				break;
			case keyCodes.pgup:
				incrementMonth(-1);
				break;
			case keyCodes.pgdown:
				incrementMonth(1);
				break;
			case keyCodes.escape:
				// eslint-disable-next-line
				close();
				break;
			case keyCodes.enter:
				registerSelection(highlighted);
				break;
			default:
				break;
		}
	}

	function registerClose() {
		document.removeEventListener('keydown', handleKeyPress);
		dispatch('close');
	}

	function close() {
		popover.close();
		registerClose();
	}

	function registerOpen() {
		$$invalidate(11, highlighted = getDefaultHighlighted());
		$$invalidate(7, month = selected.getMonth());
		$$invalidate(8, year = selected.getFullYear());
		document.addEventListener('keydown', handleKeyPress);
		dispatch('open');
	}

	const monthSelected_handler = e => changeMonth(e.detail);
	const yearSelected_handler = e => changeYear(e.detail);
	const incrementMonth_handler = e => incrementMonth(e.detail);
	const dateSelected_handler = e => registerSelection(e.detail);

	function popover_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			popover = $$value;
			$$invalidate(10, popover);
		});
	}

	function popover_1_open_binding(value) {
		isOpen = value;
		$$invalidate(13, isOpen);
	}

	function popover_1_shrink_binding(value) {
		isClosing = value;
		$$invalidate(14, isClosing);
	}

	$$self.$$set = $$props => {
		if ('format' in $$props) $$invalidate(27, format = $$props.format);
		if ('start' in $$props) $$invalidate(3, start = $$props.start);
		if ('end' in $$props) $$invalidate(4, end = $$props.end);
		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
		if ('dateChosen' in $$props) $$invalidate(26, dateChosen = $$props.dateChosen);
		if ('alwaysOpen' in $$props) $$invalidate(5, alwaysOpen = $$props.alwaysOpen);
		if ('trigger' in $$props) $$invalidate(1, trigger = $$props.trigger);
		if ('selectableCallback' in $$props) $$invalidate(28, selectableCallback = $$props.selectableCallback);
		if ('weekStart' in $$props) $$invalidate(29, weekStart = $$props.weekStart);
		if ('daysOfWeek' in $$props) $$invalidate(30, daysOfWeek = $$props.daysOfWeek);
		if ('monthsOfYear' in $$props) $$invalidate(6, monthsOfYear = $$props.monthsOfYear);
		if ('style' in $$props) $$invalidate(31, style = $$props.style);
		if ('buttonBackgroundColor' in $$props) $$invalidate(32, buttonBackgroundColor = $$props.buttonBackgroundColor);
		if ('buttonBorderColor' in $$props) $$invalidate(33, buttonBorderColor = $$props.buttonBorderColor);
		if ('buttonTextColor' in $$props) $$invalidate(34, buttonTextColor = $$props.buttonTextColor);
		if ('highlightColor' in $$props) $$invalidate(35, highlightColor = $$props.highlightColor);
		if ('dayBackgroundColor' in $$props) $$invalidate(36, dayBackgroundColor = $$props.dayBackgroundColor);
		if ('dayTextColor' in $$props) $$invalidate(37, dayTextColor = $$props.dayTextColor);
		if ('dayBorderColor' in $$props) $$invalidate(38, dayBorderColor = $$props.dayBorderColor);
		if ('dayHighlightedBackgroundColor' in $$props) $$invalidate(39, dayHighlightedBackgroundColor = $$props.dayHighlightedBackgroundColor);
		if ('dayHighlightedTextColor' in $$props) $$invalidate(40, dayHighlightedTextColor = $$props.dayHighlightedTextColor);
		if ('backgroundColor' in $$props) $$invalidate(41, backgroundColor = $$props.backgroundColor);
		if ('textColor' in $$props) $$invalidate(42, textColor = $$props.textColor);
		if ('formattedSelected' in $$props) $$invalidate(2, formattedSelected = $$props.formattedSelected);
		if ('$$scope' in $$props) $$invalidate(53, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*start, end, selectableCallback, weekStart*/ 805306392) {
			$: $$invalidate(44, months = getMonths(start, end, selectableCallback, weekStart));
		}

		if ($$self.$$.dirty[0] & /*month, year*/ 384 | $$self.$$.dirty[1] & /*months*/ 8192) {
			$: {
				$$invalidate(43, monthIndex = 0);

				for (let i = 0; i < months.length; i += 1) {
					if (months[i].month === month && months[i].year === year) {
						$$invalidate(43, monthIndex = i);
					}
				}
			}
		}

		if ($$self.$$.dirty[1] & /*months, monthIndex*/ 12288) {
			$: $$invalidate(9, visibleMonth = months[monthIndex]);
		}

		if ($$self.$$.dirty[0] & /*year, month*/ 384) {
			$: $$invalidate(18, visibleMonthId = year + month / 100);
		}

		if ($$self.$$.dirty[0] & /*visibleMonth*/ 512) {
			$: lastVisibleDate = visibleMonth.weeks[visibleMonth.weeks.length - 1].days[6].date;
		}

		if ($$self.$$.dirty[0] & /*visibleMonth*/ 512) {
			$: firstVisibleDate = visibleMonth.weeks[0].days[0].date;
		}

		if ($$self.$$.dirty[1] & /*monthIndex, months*/ 12288) {
			$: $$invalidate(16, canIncrementMonth = monthIndex < months.length - 1);
		}

		if ($$self.$$.dirty[1] & /*monthIndex*/ 4096) {
			$: $$invalidate(15, canDecrementMonth = monthIndex > 0);
		}

		if ($$self.$$.dirty[1] & /*buttonBackgroundColor, buttonBorderColor, buttonTextColor, highlightColor, dayBackgroundColor, dayTextColor, dayBorderColor, dayHighlightedBackgroundColor, dayHighlightedTextColor, backgroundColor, textColor, style*/ 4095) {
			$: $$invalidate(17, wrapperStyle = `
    --button-background-color: ${buttonBackgroundColor};
    --button-border-color: ${buttonBorderColor};
    --button-text-color: ${buttonTextColor};
    --highlight-color: ${highlightColor};
    --day-background-color: ${dayBackgroundColor};
    --day-text-color: ${dayTextColor};
    --day-border-color: ${dayBorderColor};
    --day-highlighted-background-color: ${dayHighlightedBackgroundColor};
    --day-highlighted-text-color: ${dayHighlightedTextColor};
    --background-color: ${backgroundColor};
    --text-color: ${textColor};
    ${style}
  `);
		}

		if ($$self.$$.dirty[0] & /*format, selected*/ 134217729) {
			$: {
				$$invalidate(2, formattedSelected = typeof format === 'function'
				? format(selected)
				: formatDate(selected, format));
			}
		}
	};

	return [
		selected,
		trigger,
		formattedSelected,
		start,
		end,
		alwaysOpen,
		monthsOfYear,
		month,
		year,
		visibleMonth,
		popover,
		highlighted,
		shouldShakeDate,
		isOpen,
		isClosing,
		canDecrementMonth,
		canIncrementMonth,
		wrapperStyle,
		visibleMonthId,
		sortedDaysOfWeek,
		changeMonth,
		changeYear,
		incrementMonth,
		registerSelection,
		registerClose,
		registerOpen,
		dateChosen,
		format,
		selectableCallback,
		weekStart,
		daysOfWeek,
		style,
		buttonBackgroundColor,
		buttonBorderColor,
		buttonTextColor,
		highlightColor,
		dayBackgroundColor,
		dayTextColor,
		dayBorderColor,
		dayHighlightedBackgroundColor,
		dayHighlightedTextColor,
		backgroundColor,
		textColor,
		monthIndex,
		months,
		slots,
		monthSelected_handler,
		yearSelected_handler,
		incrementMonth_handler,
		dateSelected_handler,
		popover_1_binding,
		popover_1_open_binding,
		popover_1_shrink_binding,
		$$scope
	];
}

class Datepicker extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				format: 27,
				start: 3,
				end: 4,
				selected: 0,
				dateChosen: 26,
				alwaysOpen: 5,
				trigger: 1,
				selectableCallback: 28,
				weekStart: 29,
				daysOfWeek: 30,
				monthsOfYear: 6,
				style: 31,
				buttonBackgroundColor: 32,
				buttonBorderColor: 33,
				buttonTextColor: 34,
				highlightColor: 35,
				dayBackgroundColor: 36,
				dayTextColor: 37,
				dayBorderColor: 38,
				dayHighlightedBackgroundColor: 39,
				dayHighlightedTextColor: 40,
				backgroundColor: 41,
				textColor: 42,
				formattedSelected: 2
			},
			null,
			[-1, -1, -1]
		);
	}
}

export default Datepicker;